{-# LANGUAGE InstanceSigs          #-}
{-# LANGUAGE LambdaCase            #-}
{-# LANGUAGE MultiParamTypeClasses #-}
{-# LANGUAGE RankNTypes            #-}
{-# LANGUAGE ScopedTypeVariables   #-}
{-# LANGUAGE TupleSections         #-}


module Shpadoinkle.Continuation
  ( Continuation (..), contIso
  , pur, impur, causes
  , runContinuation
  , MapContinuations (..)
  , convertC
  , liftC, liftMC
  , leftC, leftMC, rightC, rightMC
  , maybeC, maybeMC, comaybe, comaybeC, comaybeMC
  , eitherC, eitherMC
  , writeUpdate, shouldUpdate
  ) where


import qualified Control.Categorical.Functor as F
import           Control.Monad (liftM2)
import           Control.PseudoInverseCategory
import           GHC.Conc (retry)
import           UnliftIO
import           UnliftIO.Concurrent


-- | The type of a state update in Shpadoinkle. A Continuation builds up an
--   atomic state update incrementally in a series of stages. For each stage we perform
--   a monadic IO computation and we may get a pure state updating function. When
--   all of the stages have been executed we are left with a composition of the resulting
--   pure state updating functions, and this composition is applied atomically to the state.
--
--   Additionally, a Continuation stage may feature a Rollback action which cancels all state
--   updates generated so far but allows for further state updates to be generated based on
--   further monadic IO computation.
--
--   The functions generating each stage of the Continuation
--   are called with states which reflect the current state of the app, with all
--   the pure state updating functions generated so far having been
--   applied to it, so that each stage "sees" both the current state
--   (even if it changed since the start of computing the continuation), and the updates made
--   so far, although those updates are not committed to the real state until the continuation
--   finishes and they are all done atomically together.
data Continuation m a = Continuation (a -> a, a -> m (Continuation m a))
                      | Rollback (Continuation m a)
                      | Done


-- | A pure state updating function can be turned into a Continuation.
pur :: Applicative m => (a -> a) -> Continuation m a
pur = Continuation . (, const (pure Done))


-- | A monadic computation of a pure state updating function can be turned into a Continuation.
impur :: Monad m => m (a -> a) -> Continuation m a
impur m = Continuation . (id,) . const $ do
  f <- m
  return $ Continuation (f, const (return Done))


-- | A monadic computation can be turned into a Continuation which does not touch the state.
causes :: Monad m => m () -> Continuation m a
causes m = impur (m >> return id)


-- | runContinuation takes a Continuation and a state value and runs the whole continuation
--   as if the real state was frozen at the value given to runContinuation. It performs all the
--   IO actions in the stages of the continuation and returns a pure state updating function
--   which is the composition of all the pure state updating functions generated by the
--   non-rolled-back stages of the continuation. If you are trying to update a Continuous
--   territory, then you should probably be using writeUpdate instead of runContinuation,
--   because writeUpdate will allow each stage of the continuation to see any extant updates
--   made to the territory after the continuation started running.
runContinuation :: Monad m => Continuation m a -> a -> m (a -> a)
runContinuation = runContinuation' id


runContinuation' :: Monad m => (a -> a) -> Continuation m a -> a -> m (a -> a)
runContinuation' f (Continuation (g, h)) x = do
  i <- h (f x)
  runContinuation' (g.f) i x
runContinuation' _ (Rollback f) x = runContinuation' id f x
runContinuation' f Done _ = return f


-- | f is a Functor to Hask from the category where the objects are
--   Continuation types and the morphisms are functions.
class MapContinuations f where
  mapMC :: Functor m => (Continuation m a -> Continuation m b) -> f m a -> f m b


instance MapContinuations Continuation where
  mapMC = id


-- | Given a natural transformation, change a continuation's underlying functor.
convertC :: Functor m => (forall b. m b -> n b) -> Continuation m a -> Continuation n a
convertC _ Done = Done
convertC f (Rollback r) = Rollback (convertC f r)
convertC f (Continuation (g, h)) = Continuation . (g,) $ \x -> f $ convertC f <$> h x


-- | Apply a lens inside a continuation to change the continuation's type.
liftC :: Functor m => (a -> b -> b) -> (b -> a) -> Continuation m a -> Continuation m b
liftC _ _ Done = Done
liftC f g (Rollback r) = Rollback (liftC f g r)
liftC f g (Continuation (h, i)) = Continuation (\x -> f (h (g x)) x, \x -> liftC f g <$> i (g x))


-- | Given a lens, change the value type of f by applying the lens in the continuations inside f.
liftMC :: Functor m => MapContinuations f => (a -> b -> b) -> (b -> a) -> f m a -> f m b
liftMC f g = mapMC (liftC f g)


-- | Change the type of a continuation by applying it to the left coordinate of a tuple.
leftC :: Functor m => Continuation m a -> Continuation m (a,b)
leftC = liftC (\x (_,y) -> (x,y)) fst


-- | Change the type of f by applying the continuations inside f to the left coordinate of a tuple.
leftMC :: Functor m => MapContinuations f => f m a -> f m (a,b)
leftMC = mapMC leftC


-- | Change the type of a continuation by applying it to the right coordinate of a tuple.
rightC :: Functor m => Continuation m b -> Continuation m (a,b)
rightC = liftC (\y (x,_) -> (x,y)) snd


-- | Change the value type of f by applying the continuations inside f to the right coordinate of a tuple.
rightMC :: Functor m => MapContinuations f => f m b -> f m (a,b)
rightMC = mapMC rightC


-- | Transform a continuation to work on Maybes. If it encounters Nothing, then it cancels itself.
maybeC :: Applicative m => Continuation m a -> Continuation m (Maybe a)
maybeC Done = Done
maybeC (Rollback r) = Rollback (maybeC r)
maybeC (Continuation (f, g)) = Continuation . (fmap f,) $
  \case
    Just x -> maybeC <$> g x
    Nothing -> pure (Rollback Done)


-- | Change the value type of f by transforming the continuations inside f to work on Maybes using maybeC.
maybeMC :: Applicative m => MapContinuations f => f m a -> f m (Maybe a)
maybeMC = mapMC maybeC


-- | Turn a 'Maybe a' updating function into an 'a' updating function which acts as
--   the identity function when the input function outputs Nothing.
comaybe :: (Maybe a -> Maybe a) -> (a -> a)
comaybe f x = case f (Just x) of
  Nothing -> x
  Just y -> y


-- | Change the type of a Maybe-valued continuation into the Maybe-wrapped type.
--   The resulting continuation acts like the input continuation except that
--   when the input continuation would replace the current value with Nothing,
--   instead the current value is retained.
comaybeC :: Functor m => Continuation m (Maybe a) -> Continuation m a
comaybeC Done = Done
comaybeC (Rollback r) = Rollback (comaybeC r)
comaybeC (Continuation (f,g)) = Continuation (comaybe f, fmap comaybeC . g . Just)


-- | Transform the continuations inside f using comaybeC.
comaybeMC :: Functor m => MapContinuations f => f m (Maybe a) -> f m a
comaybeMC = mapMC comaybeC


-- Just define these rather than introducing another dependency even though they are in either
mapLeft :: (a -> b) -> Either a c -> Either b c
mapLeft f (Left x) = Left (f x)
mapLeft _ (Right x) = Right x


mapRight :: (b -> c) -> Either a b -> Either a c
mapRight _ (Left x) = Left x
mapRight f (Right x) = Right (f x)


-- | Combine continuations heterogeneously into coproduct continuations.
--   The first value the continuation sees determines which of the
--   two input continuation branches it follows. If the coproduct continuation
--   sees the state change to a different Either-branch, then it cancels itself.
--   If the state is in a different Either-branch when the continuation
--   completes than it was when the continuation started, then the
--   coproduct continuation will have no effect on the state.
eitherC :: Monad m => Continuation m a -> Continuation m b -> Continuation m (Either a b)
eitherC f g = Continuation . (id,) $ \case
  Left x -> case f of
    Done -> return Done
    Rollback r -> return . Rollback $ eitherC r Done
    Continuation (h, i) -> do
      j <- i x
      return $ Continuation (mapLeft h, const . return $ eitherC j (Rollback Done))
  Right x -> case g of
    Done -> return Done
    Rollback r -> return . Rollback $ eitherC Done r
    Continuation (h, i) -> do
      j <- i x
      return $ Continuation (mapRight h, const . return $ eitherC (Rollback Done) j)


-- | Create a structure containing coproduct continuations using two case
--   alternatives which generate structures containing continuations of
--   the types inside the coproduct. The continuations in the resulting
--   structure will only have effect on the state while it is in the branch
--   of the coproduct selected by the input value used to create the structure.
eitherMC :: Monad m => MapContinuations f => (a -> f m a) -> (b -> f m b) -> Either a b -> f m (Either a b)
eitherMC l _ (Left x) = mapMC (\c -> eitherC c (pur id)) (l x)
eitherMC _ r (Right x) = mapMC (\c -> eitherC (pur id) c) (r x)


-- | Transform the type of a continuation using an isomorphism.
contIso :: Functor m => (a -> b) -> (b -> a) -> Continuation m a -> Continuation m b
contIso f g (Continuation (h, i)) = Continuation (f.h.g, fmap (contIso f g) . i . g)
contIso f g (Rollback h) = Rollback (contIso f g h)
contIso _ _ Done = Done


-- | Continuation m is a functor in the EndoIso category (where the objects
--   are types and the morphisms are EndoIsos).
instance Applicative m => F.Functor EndoIso EndoIso (Continuation m) where
  map (EndoIso f g h) =
    EndoIso (Continuation . (f,) . const . pure) (contIso g h) (contIso h g)


-- | You can combine multiple continuations homogeneously using the Monoid typeclass
--   instance. The resulting continuation will execute all the subcontinuations in parallel,
--   allowing them to see each other's state updates and roll back each other's updates,
--   applying all of the updates generated by all the subcontinuations atomically once
--   all of them are done.
instance Monad m => Semigroup (Continuation m a) where
  (Continuation (f, g)) <> (Continuation (h, i)) =
    Continuation (f.h, \x -> liftM2 (<>) (g x) (i x))
  (Continuation (f, g)) <> (Rollback h) =
    Rollback (Continuation (f, (\x -> liftM2 (<>) (g x) (return h))))
  (Rollback h) <> (Continuation (_, g)) =
    Rollback (Continuation (id, \x -> liftM2 (<>) (return h) (g x)))
  (Rollback f) <> (Rollback g) = Rollback (f <> g)
  f <> Done = f
  Done <> f = f


-- | Since combining continuations homogeneously is an associative operation,
--   and this operation has a unit element (Done), continuations are a Monoid.
instance Monad m => Monoid (Continuation m a) where
  mempty = Done


writeUpdate' :: MonadUnliftIO m => (a -> a) -> TVar a -> (a -> m (Continuation m a)) -> m ()
writeUpdate' h model f = do
  i <- readTVarIO model
  m <- f (h i)
  case m of
    Continuation (g,gs) -> writeUpdate' (g.h) model gs
    Done -> atomically $ writeTVar model =<< h <$> readTVar model
    Rollback gs -> writeUpdate' id model (const (return gs))


-- | Run a continuation on a state variable. This may update the state.
writeUpdate :: MonadUnliftIO m => TVar a -> (a -> m (Continuation m a)) -> m ()
writeUpdate = writeUpdate' id


-- | Execute a fold by watching a state variable and executing the next
--   step of the fold each time it changes.
shouldUpdate :: MonadUnliftIO m => Eq a => (b -> a -> m b) -> b -> TVar a -> m ()
shouldUpdate sun prev model = do
  i' <- readTVarIO model
  p  <- newTVarIO i'
  () <$ forkIO (go prev p)
  where
    go x p = do
      a <- atomically $ do
        new' <- readTVar model
        old  <- readTVar p
        if new' == old then retry else new' <$ writeTVar p new'
      y <- sun x a
      go y p
