= Tutorial

Here we will build a simple calculator, following two pioneers of the space http://weblog.luite.com/wordpress/?p=127[Luite Stegemann] and https://reflex-frp.org/tutorial[Ryan Trinkle].

== Hello World

Let's get a basic Hello World app up. Luckily that is not too hard (but not too easy either).

[source,haskell]
----
main :: IO ()
main = runJSorWarp 8080 $ -- <1>
  simple -- <2>
    runParDiff -- <3>
    () -- <4>
    (const "hello world") -- <5>
    getBody -- <6>
----

<1> This is a little function to abstract over starting the application with GHC or GHCjs. If built with GHC it will run a server on port `8080`, if built with GHCjs it will just start the application as a normal JavaScript file.
<2> This is the highest level wrapper around the `shpadoinkle` function provided in core. It prevents you from doing the work of choosing a `Monad` to run event handlers (defaulting to `JSM`), and creating a territory (defaulting to a `TVar`).
<3> We are using the ParDiff backend. No matter how simple the app, you must still choose a backend explicitly.
<4> The initial state. Since this is a "hello world" example, it's just `()`.
<5> This is our view. Since we don't care about the `()` we using `const` here. `"hello world"` is an `OverloadedString`, of type `Html m a`.
<6> This is what DOM node on the page will hold our application. We use `getBody` to get the `document.body` for the page.

== Addition

Now that we have our hello world, let's add some interactivity, and perform addition on the part of the user.

To start we will need a simple single number input.

[source,haskell]
----
num :: MonadJSM m => Int -> Html m Int
num x = input'
 [ value . pack $ show x -- <1>
 , onInput (fromMaybe 0 . readMay . unpack) -- <2>
 ]
----

Because we have our first handler, we need `MonadJSM` since allocation of the listener requires IO.

<1> Set the value of the input to the current state of the application.
<2> When an `"input"` event occurs update the state with the provided function.

Now we can use our single number input in our view to add up two numbers for our user.

[source,haskell]
----
view :: MonadJSM m => (Int, Int) -> Html m (Int, Int)
view (l,r) = -- <1>
  div_
    [ (,r) <$> num l -- <2>
    , " + "
    , (l,) <$> num r -- <3>
    , text $ " = " <> pack (show $ l + r) -- <4>
    ]
----

<1> For now we can just use a tuple to house our two numbers.
<2> We use the `num` component, rendering it with `l`.
<3> We use the `num` component, rendering it with `r`.
<4> We display the result of `l + r` to the user.

[NOTE]
.Heterogenious Composition
We are using `<$>` and a `TupleSection` here to compose our `num` component. This is because `Html m Int` and `Html m (Int, Int)` obviously do not unify. Since `(Html m)` is merely a Functor, fmap is the only means provided to resolve impediences and compose herogeneous components (as we do here).

== Selectable Operations

Now that we have some inputs that can perform addition, let's allow the user to select common operations. We start by making a new ADT.

[source,haskell]
----
data Operation
 = Addition
 | Subtraction
 | Multiplication
 | Division


opText :: Operation -> Text
opText = \case
  Addition       -> "+"
  Subtraction    -> "-"
  Multiplication -> "x"
  Division       -> "/"


opFunction :: Operation -> (Int -> Int)
opFunction = \case
  Addition       -> (+)
  Subtraction    -> (-)
  Multiplication -> (x)
  Division       -> (/)


textOp :: Text -> Maybe Operation
textOp = \case
  "+" -> Just Addition
  "-" -> Just Subtraction
  "x" -> Just Multiplication
  "/" -> Just Division
  _   -> Nothing
----
