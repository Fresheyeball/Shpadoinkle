= Html

This package exposes a Haskell-generated template Digital Subscriber Line (DSL) of HTML tags, as well as properties. While not complete, this package is intended to eventually house utilities for web APIs.

== Named Tags

HTML tags each get **four** named functions, with the following semantic:

[%header]
|===
| Variant | Properties Required | Children Required
| Plain | icon:check[] Yes | icon:check[] Yes
| Prime | icon:check[] Yes | icon:times[] No
| Underscore | icon:times[] No | icon:check[] Yes
| Prime + Underscore | icon:times[] No | icon:times[] No
|===

or you can see the semantic as follows:

[source,haskell]
----
x [] = x'
flip x [] = x_
x [] [] = x'_
h "x" = x
----

You also supply some overload strings for convenience:

[source,haskell]
----
div "foo" [ "hiya" ]
> <div class="foo">hiya</div>
----

== Event Listeners

Event listeners each get **three** named functions; a plain one, for pure event handlers, and an `M` version for Monadic handlers, and an `E` variate for full flexibility. Each of these functions is named the same as in JavaScript (sans Camel-case). See that the following are morally equivalent:

[source,javascript]
----
div.addEventListener("click", () => model++);
----

[source,haskell]
----
div' [ onClick (model + 1) ]
----

The plain variant is polymorphic and will work with Functorial and EndoIso props. However the Monaic variant is monomorphic and demands `PropM`

[source,haskell]
----
onClick :: IsProp p e => a -> (Text, p a)
onClickM :: Monad m => m (a -> a) -> (Text, PropM m a)
----

You will also note that one take an `a` and the other `m (a -> a)`. This is because your Monadic action may be asynchronous, and the state of the application may have changed durring that time. The returned function `(a -> a)` will be applied as a state update to whatever that state is once the action completes.

[NOTE]
====
.onClickE
Documentation in progress. This variant allows raw access to the xref:packages/core.adoc#_continuation[Continuation].
[source,haskell]
----
onClickE :: IsProp p e => e a -> (Text, p a)
----
====

=== Affordances

Some listeners provide extra information. For example

[source,haskell]
----
onInput :: IsProp p e => (Text -> a) -> (Text, p a)
----

where the `Text` will be the current value of the input element, preventing us from having to write low level code to extract the value.

== Properties

Instead of orienting around attributes, we orient around _properties_ in Shpadoinkle. This is because, largely you can set any attribute by properties, but not vice-versa. Credit due to https://kriszyp.github.io/alkali/[alkali] which introduced the author to this observation.

In most cases the named function will have the same name it would have in JavaScript. For example, the following are morally equivalent:

[source,javascript]
----
const div = document.createElement("div");
div.className = "foo";
----

[source,haskell]
----
div' [ className "foo" ]
----

Not all properties have the same type. While we endeavor to provide semantic types for the properties involved, this is not yet always the case. Please feel free to submit MR's if you encounter impedances, or would like to suggest a function.


=== ClassName

This is by **far** the most common property to set. And so extra affordances are offered here. These are provide in **outlaw** fashion with typeclasses.

[source,haskell]
----
div' "foo bar"
div' [ className "foo bar" ]
div' [ className ("foo bar", True) ]
div' [ className ["foo", "bar"] ]
div' [ className [("foo", True), ("bar", True), ("baz", False)] ]
----

will all render as

[source,html]
----
<div class="foo bar" ></div>
----

You can also use the {hackage}-html/docs/Shpadoinkle-Html-Property.html#t:ClassList[`ClassList` newtype], to build up classes for an element.

== Memo

The memo function remembers the last arguement passed, and the last result. When a new value is passed, it compares it with the previous value, if they match, the previous result is returned from memory. This is useful when computing `Html`. It is expensive and benefits from memoization:

[source,haskell]
----
memo = id
----

Think of `memo` as a way of changing the evaluation strategy:

[source,haskell]
----
view :: Text -> Html a
view = memo $ \t ->
  div_ . take (length t) . repeat . text $ expensiveFilter t
----
